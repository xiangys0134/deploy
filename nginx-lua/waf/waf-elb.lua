---
--- Generated by Luanalysis
--- Created by Yusin Xiang
--- DateTime: 2021/6/9 10:53
---
local ua = ngx.var.http_user_agent
local uri = ngx.var.request_uri
local url = ngx.var.host .. uri
local redis = require "resty.redis"
local red = redis.new()
local CCcount = 10
local CCseconds = 50
local Redisremote_ip = '172.20.20.206'
local RedisPORT = 6379
local blackseconds = 300
local private_network = '172.20'

if ua == nil then
    ua = "unknown"
end

-- redis连接池设置
function close_redis(red)
    if not red then
        return
    end
    local pool_max_idle_time = 10000
    local pool_size = 100
    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)

    if not ok then
        ngx.log(ngx.ERR, "set redis keepalive error: ", err)
    end
end

-- 获取远程clientip
function getclientremote_ip()
    -- 当nginx处于alb下游时使用，当nginx处于最前端时参考waf-front.lua
    local remote_ip = ngx.req.get_headers()["x_forwarded_for"]

    --if remote_ip == nil then
    --    remote_ip  = ngx.var.remote_addr
    --end
    if remote_ip == nil then
        remote_ip  = "unknown"
    end

    -- 匹配x_forwarded_for标头值是否带有','
    local index,to,err = ngx.re.find(remote_ip, ",", "jo")
    if index then
        ngx.log(ngx.ERR,'x_forwarded_for error: ',remote_ip)
        ngx.exit(403)
        close_redis()
    end

    return remote_ip
end

function rule_ip(ip,red)
    -- 匹配局域网ip网段，防止loadbance健康检查异常
    local from, to, err = ngx.re.find(ip, private_network, "jo")
    if from then
        return
    end

    -- 获取白名单匹配-192.168.1.5
    local white_flag = red:exists('white_ip')
    if white_flag == 1 then
        local res, err = red:lrange('white_ip', 0, 1)
        if res ~= nil then
            for i,v in ipairs(res) do
                --ngx.log(ngx.ERR, "ip:>>>> ", v)
                if remote_ip == v then
                    ngx.log(ngx.ERR, "white ip ", v)
                    return 1
                end
            end
        else
            ngx.log(ngx.ERR, "white ip error+++++:  ", err)
        end
    end

    -- 黑名单处理
    local token = ip .. "." .. ngx.md5(url .. ua)
    local req = red:exists(token)
    if req == 0 then
        red:incr(token)
        red:expire(token,CCseconds)
        ngx.log(ngx.ERR, "blacklist++ ", ip)
        return 0
    else
        local count_number = tonumber(red:get(token))
        if count_number >= CCcount then
            local blackreq = red:exists("black." .. token)
            if blackreq  == 1 then
                ngx.log(ngx.ERR, "shield ip:", ip)
                close_redis()
                ngx.exit(403)
            else
                red:set("black." .. token,1)
                red:expire("black." .. token,blackseconds)
                red:expire(token,blackseconds)
                close_redis()
                ngx.exit(403)
            end
            return 2
        else
            red:incr(token)
            return 3
        end
    end
end


-- 获取clientip
local remote_ip = getclientremote_ip()

red:set_timeout(60)
local ok, err = red.connect(red, Redisremote_ip, RedisPORT)

-- 连接失败释放连接退出
if not ok then
    ngx.log(ngx.ERR, "Redis cannot connect ", err)
    --return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
    return
else
    -- 获取clientip
    local remote_ip = getclientremote_ip()

    local set_ip = rule_ip(remote_ip,red)
    if set_ip then
        if set_ip == 1 then
            ngx.log(ngx.ERR,"return : ", '0')
        elseif set_ip == 1 then
            ngx.log(ngx.ERR,"return : ", '1')
        elseif set_ip == 2 then
            ngx.log(ngx.ERR,"return : ", '2')
        elseif set_ip == 3 then
            ngx.log(ngx.ERR,"return : ", '3')
        else
            ngx.log(ngx.ERR,"return : ", 'operation failed')
        end
    end

    close_redis()
end






